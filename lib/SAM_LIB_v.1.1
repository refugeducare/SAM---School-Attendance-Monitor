// parent folder lib                https://drive.google.com/drive/folders/1TDPXDxs3-HIH1r5Rz6RUz7QBVQnEHlXw?usp=drive_link
// googleSheet   SAM_LIB_v.1.1      https://docs.google.com/spreadsheets/d/11XtAcRyst1d-JOaSfa2HWFrVfGWivmpYXfirxkAcLHg/edit#gid=302833560
// bound script  SAM_LIB_v.1.1      https://script.google.com/u/0/home/projects/1wfugfE_ootIFLRGaQsvyKxJGWkat90em2NFbj9TId0F7FPdYTsiWn5qM/edit

//*******************************************************************************************************************************************************
// UAMS GLOBAL ******************************************************************************************************************************************
//*******************************************************************************************************************************************************
const startRow = 5;
const endRow = 105;
const entryFirstCol = "3";      // col C
const entryLastCol = "23";      // col W
const entryRow = 3;
const entryRowRangeA1 = "C3:W3";
const cellStoredRecA1 = "B1";
const studentSheetName = 'students';
const ticksRangeA1 = 'I5:I105';
const dikaCol = 3;
const ammCol = 12;
const triggeringActions = {
  'uams' : {
    'cell' : {
      'B3' : addRec,
      'I3' : undeletableCheckboxes_
    },
    'range' : {
      'B5:B105' : editDelete
    },
    'peerSheetName' : 'uamsPhantom'
  },
  [studentSheetName] : {    // 'students'
    'cell' : {},
    'range' : {
      'J5:N105' : storEdited,
      'S5:IH105' : storEdited,
      'A5:H105' : delEntry,
      [ticksRangeA1] : storeEditedTick    // 'I5:I105'
    },
    'peerSheetName' : 'uamsPhantom'
  },
}
//*******************************************************************************************************************************************************
// UAMS GLOBAL ******************************************************************************************************************************************
//*******************************************************************************************************************************************************
/*************************************************************************************/
function onOpen() {
  var ui = SpreadsheetApp.getUi();
  ui.createMenu('SAM')
    .addItem('Update Attendance', 'actualizeAttendanceLib')
    .addToUi();
}
/*****************************************/
/*************************************************************************************/
function onEdit(e) {
  if (!e) {
    throw new Error(
      'Please do not run the onEdit(e) function in the script editor window. '
      + 'It runs automatically when you hand edit the spreadsheet.'
    );
  }
  let eSheet = e.source.getActiveSheet();
  let eSheetName = eSheet.getName();
  let eRange = e.range;
  let eCell = eRange.getA1Notation();
        // If a single cell is triggering, run the corresponding triggered function. Triggering cells in different sheets are triggering different functions. The eSheetName is determining which sheet triggers and eCell is determining which cell is triggering.
  if (triggeringActions.hasOwnProperty(eSheetName)) {
    if (triggeringActions[eSheetName].cell.hasOwnProperty(eCell)) {
      triggeringActions[eSheetName].cell[eCell](e);
      return; // Exit the function to avoid processing range-based actions
    } 
    else {
          // If a cell from a range is triggering, run the corresponding triggered function. Triggering cells from ranges in different sheets are triggering different functions. The eSheetName is determining which sheet triggers and eCell is determining which cell is triggering. 
      for (var range in triggeringActions[eSheetName].range) {
        let rangeParts = range.split(':');
        let startCellA1 = rangeParts[0];
        let endCellA1 = rangeParts[1];
        let startCell = eRange.getSheet().getRange(startCellA1);
        let endCell = eRange.getSheet().getRange(endCellA1);
                    // Check if the edited cell is within the range
        if (
          eRange.getRow() >= startCell.getRow() &&
          eRange.getRow() <= endCell.getRow() &&
          eRange.getColumn() >= startCell.getColumn() &&
          eRange.getColumn() <= endCell.getColumn()
        ) {

          triggeringActions[eSheetName].range[range](e);
          return; // Exit the function after executing the range-based action
        }
      }
    }
  }  
}
/*************************************************************************************/
function editDelete(e) {
  let eRange = e.range;
  if (e.value === "EDIT") {
    editRec(e);
  } else if (e.value === "DELETE") {
    deleteRec(e);
  }
  eRange.setValue("");
}
/*************************************************************************************/
          // Get the record to edit and put it to the entry row. Save the original position of the record in order to write it back to the same position. Source of the record to edit is the active sheet, which in turn gets the record via arrayformula() from the peer sheet (the phantomSheet). Record is written back to the peer sheet (target is the phantomSheet)
function editRec(e) {
  let eSheet = e.source.getActiveSheet();
  let eSheetName = eSheet.getName();
  let phantomSheetName = triggeringActions[eSheetName].peerSheetName;
  let eRow =  e.range.getRow();
      // Get the values of the entire row
  let editedRecord = eSheet.getRange(eRow, entryFirstCol, 1, entryLastCol - entryFirstCol + 1);
  var recordValues = editedRecord.getValues()[0];
      // Put the values (the record to edit) to the entry row. 
  let entryRowRange = e.source.getRange(entryRowRangeA1);
  entryRowRange.setValues([recordValues]);
      // Save the original position of the record in order to write it back to the same position.
  let cellStoredRec = e.source.getSheetByName(phantomSheetName).getRange(cellStoredRecA1);    // cell B1
  cellStoredRec.setValue(editedRecord.getA1Notation()); 
}
/*************************************************************************************/
      // When finished with editing the entry row, write the record back to its original position or to a new row in the database. Record is written to the peer sheet (target is the phantomSheet)
function addRec(e) {
  let eSheet = e.source.getActiveSheet();
  let eSheetName = eSheet.getName();
  let phantomSheetName = triggeringActions[eSheetName].peerSheetName;
  let cellStoredRec = e.source.getSheetByName(phantomSheetName).getRange(cellStoredRecA1);    // cell B1
  let entryRowRange = e.source.getRange(entryRowRangeA1);
  let entryRowData = entryRowRange.getValues();
  if (e.value === 'OK') {                               // user hit OK
    let storedRecA1 = cellStoredRec.getValue();         // cell B1
          // if there is an original position stored in B1, that is the user is editing an already existing record    
    if (storedRecA1 != '') {
      let storedRec = e.source.getSheetByName(phantomSheetName).getRange(storedRecA1);
      let storedRecRow = storedRec.getRow();
          // if there are no duplicate values entered (ΔΙΚΑ dikaCol=3 --- ΑΡΙΘΜΟΣ ΜΑΘΗΤΙΚΟΥ ΜΗΤΡΩΟΥ ammCol=12)
      if (noDuplicates(e, dikaCol, storedRecRow) && noDuplicates(e, ammCol, storedRecRow)
          && notEmpty(e, dikaCol)) {       // check if ΔΙΚΑ is empty
            // write the edited record back to its original position
        storedRec.setValues(entryRowData);
      } else {
        e.range.setValue("");                               // clear the duplicate entered cell
        return;                                             // go back and wait for the user to complete the edit
      }
          // if there is NO original position stored in B1, that is the user is asserting a new record    
    } else {  
          // if there are no duplicate values entered (ΔΙΚΑ dikaCol=3 --- ΑΡΙΘΜΟΣ ΜΑΘΗΤΙΚΟΥ ΜΗΤΡΩΟΥ ammCol=12)
      if (noDuplicates(e, dikaCol) && noDuplicates(e, ammCol)
          && notEmpty(e, dikaCol)) {       // check if ΔΙΚΑ is empty
        let newRecRow = e.source.getLastRow() + 1;          // go to the first empty row
                                                            // write the new record
        e.source.getSheetByName(phantomSheetName).getRange(newRecRow, entryFirstCol, 1, entryLastCol - entryFirstCol + 1).setValues(entryRowData);
            // if there ARE duplicates
      } else {
        e.range.setValue("");                               // clear the duplicate entered cell
        return;                                             // go back and wait for the user to complete the edit
      }
    }
  }
        // Ticks in sheet students are not automatically updated after the edited record is added. The ticks-column in sheet students is not included in the importrange formula in order to make them editable by the user. Therefore the ticks must be updated after every edit in sheet uams
  updateTick(e, studentSheetName, ticksRangeA1);
        // clear anything not needed
  cellStoredRec.setValue('');
  e.range.setValue("");
  let blankValues = new Array(1).fill(new Array(entryLastCol - entryFirstCol + 1).fill(""));
  // blankValues[0][0] = " ";  // The first cell must not be blank because it is used by the formula in the column left to it to generate the numbering
  blankValues[0][6] = false;  // The tickbox mus be set to false
  // blankValues[0][6] = "";  // The tickbox mus be set to ""
  entryRowRange.setValues(blankValues);
}
/*************************************************************************************/
        // delete the record and shift the rest of rows one position up. Record is deleted from the peer sheet (target is the phantomSheet)
function deleteRec(e) {
  let eSheet = e.source.getActiveSheet();
  let eSheetName = eSheet.getName();
  let phantomSheetName = triggeringActions[eSheetName].peerSheetName;
  let phantomSheet = e.source.getSheetByName(phantomSheetName);
  let eRow =  e.range.getRow();
  let eCol = e.range.getColumn();
  let lastRow = eSheet.getLastRow();
  let lastCol = eSheet.getLastColumn();
  if (eRow != lastRow) {
    let rangeToShiftUp = phantomSheet.getRange(eRow + 1, entryFirstCol, lastRow - eRow, lastCol - eCol);
    rangeToShiftUp.copyTo(phantomSheet.getRange(eRow, entryFirstCol, lastRow - eRow, lastCol - eCol));
  }
      // clear the last row as it became duplicate after the previous copy  
  let blankValues = new Array(1).fill(new Array(lastCol).fill(""));
  phantomSheet.getRange(lastRow, 1, 1, lastCol).setValues(blankValues);
        // Ticks in sheet students are not automatically updated after the edited record is added. The ticks-column in sheet students is not included in the importrange formula in order to make them editable by the user. Therefore the ticks must be updated after every edit in sheet uams
  updateTick(e, studentSheetName, ticksRangeA1);
}
/*************************************************************************************/
          // write one value from the current position to the same position in peer sheet (the phantom sheet)
function storEdited(e) {
  let eSheet = e.source.getActiveSheet();
  let eSheetName = eSheet.getName();
  let phantomSheetName = triggeringActions[eSheetName].peerSheetName;
  let eRow =  e.range.getRow();
  let eCol = e.range.getColumn();
  e.source.getSheetByName(phantomSheetName).getRange(eRow, eCol).setValue(e.value);
  e.range.setValue('');
}
/*************************************************************************************/
          // store the changed tick from current position to its destination, that is to the same position in the peer sheet (the phantom sheet)
function storeEditedTick(e) {
  let eSheet = e.source.getActiveSheet();
  let eSheetName = eSheet.getName();
          // Get the name of the current function
  let functionName = storeEditedTick.name;
          // Locate the function in the object and get the key // foundKey='I5:I105'
  let foundKey = Object.keys(triggeringActions[eSheetName].range).find(key => triggeringActions[eSheetName].range[key].name === functionName);
  storEdited(e);    // store the value from current cell to the same position in the peer sheet 
  updateTick(e, eSheetName, foundKey);   // foundKey='I5:I105'
}
/*************************************************************************************/
        // Ticks in sheet students are not automatically updated after the edited record is added. The ticks-column in sheet students is not included in the importrange formula in order to make them editable by the user. Therefore the ticks must be updated after every edit in sheet uams
function updateTick(e, eSheetName, tickRangeA1) { 
  let eSheet = e.source.getSheetByName(eSheetName);
  let phantomSheetName = triggeringActions[eSheetName].peerSheetName;
  let phantomSheet = e.source.getSheetByName(phantomSheetName);
  let newValues = phantomSheet.getRange(tickRangeA1).getValues();
  let tickRange = eSheet.getRange(tickRangeA1);
  tickRange.setValues(newValues);
}
/*************************************************************************************/
                     // check if ΔΙΚΑ is empty
function notEmpty(e, emptyCol) {
  let eSheet = e.source.getActiveSheet();
  let emptyCell = eSheet.getRange(entryRow, emptyCol);
  // let isEmpty = (valArr[pos-1] === "" || valArr[pos-1] === null);
  let isEmpty = emptyCell.isBlank();
  if (isEmpty) {
        // Value is empty, show an alert and clear the cell
    Browser.msgBox(eSheet.getRange(2, emptyCol).getValue() + " in column >>> " + getColumnLetter(emptyCol) + "  can not be empty. Please enter a value.");
    e.range.clearContent();
  }
        // Return true if value is not empty, otherwise, return false
  return !isEmpty;
}
/*************************************************************************************/
          // check for duplicate values in noDupCol excluding row exclRow. Excludig of a certain is needed in case of editing an already existent record, that has in noDupCol the same value as in the corresponding cell of entryRow. This in fact is not a duplicate value, as the entryRow holds a temporary copy of the original values. Therefore the original row containing the 'duplicate' value must be removed from the array to compare with. 
function noDuplicates(e, noDupCol, exclRow = null) {    // exclRow is optional
  let eSheet = e.source.getActiveSheet();
  let noDupCell = eSheet.getRange(entryRow, noDupCol);
  let newValue = noDupCell.getValue();
  if (newValue === '') {
    return true;
  } else {
        // Define the range in column C from editedCell (row 5) to row 105
    let rowCount = endRow - startRow + 1;   // =105-5+1
    let uniqueCol = eSheet.getRange(startRow, noDupCol, rowCount, 1).getValues().flat().filter(value => value !== "");
        // If exclRow is provided and not null, find its index and remove it
    if (exclRow !== null) {
      // let indexToRemove = uniqueCol.indexOf(exclRow - startRow + 1);
      let indexToRemove = exclRow - startRow;
          // Remove the element at indexToRemove from uniqueCol
      if (indexToRemove !== -1) {
        uniqueCol.splice(indexToRemove, 1);
      }
    }
        // Initialize a boolean variable to track if a duplicate is found
    var isDuplicate = uniqueCol.indexOf(newValue) !== -1;
    if (isDuplicate) {
          // Value is not unique, show an alert and clear the cell
      Browser.msgBox(eSheet.getRange(2, noDupCol).getValue() + " >>> Duplicate value detected in column " + getColumnLetter(noDupCol) + ". Please enter a unique value.");
      noDupCell.clearContent();
    }
          // Return true if no duplicates were found, otherwise, return false
    return !isDuplicate;
  }
}
/*************************************************************************************/
      // Clear the contents of the edited cell(s). This is needed in case the user enters a value in a cell where an arrayformula is writing data. In this case the arreyformula stops and gice a REF error. Deleting the users entry allows the arrayformula to regenerate the data.
function delEntry(e) {
  var editedRange = e.range;
  editedRange.setValue("");
}
/*************************************************************************************/
function getColumnLetter(columnNumber) {
      // Assuming columnNumber is 1-based (e.g., 1 for column A, 2 for B, 3 for C, etc.)
  var columnLetter = String.fromCharCode(64 + columnNumber);
  return columnLetter;
}
/*************************************************************************************/
//#region WORKING_VERSION_1 01/09/23
/*************************************************************************************/
/*************************************************************************************/
              // Read file attendance_ >>> sheet "Attendance" and write the actual presences into file studentsDB >>> sheet "studentsDB_Attendance" in order to store them centrally
function preserveAttendance() {
/*************************************************************************************/  
              // file 'base_attendance_' is the active spreadsheet which is calling this script and also the spreadsheet where the programDATA are stored. 
var activeSS = SpreadsheetApp.getActive();  
              // in this sheet are stored the data to assign to the variables needed inside this script. This is the central ProgramDATA (belongs to library)
const PROGRAM_DATA_SHEET = SpreadsheetApp.openById('11XtAcRyst1d-JOaSfa2HWFrVfGWivmpYXfirxkAcLHg').getSheetByName('ProgramData');   
const PROGRAM_DATA_SHEET_LOC = activeSS.getSheetByName('ProgramData');                    // this is the local ProgramDATA (belongs to the active file) 
const PROG_DATA = PROGRAM_DATA_SHEET.getDataRange().getValues();                          // get the whole library datasheet
const PROG_DATA_LOC = PROGRAM_DATA_SHEET_LOC.getDataRange().getValues();                  // get the whole local datasheet
const ATT_ID = getVar(PROG_DATA_LOC, 'ATT_ID');                                           // The ID of the local file attendance_ (the local peer)
const ATT_Attendance = getVar(PROG_DATA, 'ATT_Attendance');                               // sheet Attendance (of file attendance_)
const ATT_AttendanceRange = getVar(PROG_DATA, 'ATT_AttendanceRange');                     // E5:FQ105
const ATT_index = getVar(PROG_DATA, 'ATT_index');                                         // B5:B105
      // const BASE_ATT_index = getVar(PROG_DATA, 'BASE_ATT_index');                            // replaced with STUD_DB_index  02/09/2023
      // const BASE_ATT_attendanceFirstCol = getVar(PROG_DATA, 'BASE_ATT_attendanceFirstCol');     // col 23 (col W in A1 notation)
      // former was col 20 (col T in A1 notation) // former was col 23 (col W in A1 notation)
      // col 24  (col T in A1 notation) changed to 24 because of the addition of the 4 columns "ΣΥΝΟΛΟ ΩΡΙΑΙΩΝ ΑΠΟΥΣΙΩΝ" "ΗΜΕΡΕΣ ΠΑΡΟΥΣΙΩΝ" "ΗΜΕΡΕΣ ΛΕΙΤΟΥΡΓΙΑΣ ΣΧΟΛΕΙΟΥ" "ΠΑΡΟΥΣΙΕΣ %"
const BASE_ATT_attendanceFirstCol = 24;     
const BASE_ATT_attendanceWidth = getVar(PROG_DATA, 'BASE_ATT_attendanceWidth');           // width 169 columns
const DATA_FIRST_ROW = getVar(PROG_DATA, 'DATA_FIRST_ROW');                               // row 5
// This is because of permission to access STUD_DB_ID. Writing is redirected to file base_attendance_ (the file which calls this library)
// const STUD_DB_ID = getVar(PROG_DATA_LOC, 'STUD_DB_ID');                                   // file 'studentsDB' ID = 1FPF_vpC7n66fAXjLTpvw7PGMgK1CL1YYHcNtF6X5RIg
const STUD_DB_ID = activeSS.getId();                                   // redirect to file base_attendance_ (this file) because of permission issues
// const STUD_DB_names = getVar(PROG_DATA_LOC, 'STUD_DB_names');                             // studentsDB!B5:E
const STUD_DB_names = 'uamsPhantom!B5:E';                             // uamsPhantom!B5:E // former was studentsDB!B5:E
const STUD_DB_index = getVar(PROG_DATA_LOC, 'STUD_DB_index');                             // C5:C
/*************************************************************************************/
  let sourceSS_ID = ATT_ID;                                      // file attendance_  (1n6yXN6nyE2mFQvfjo7Zw6WzHih53q11q6FdZWXQhLHw)
  let sourceSheetName = ATT_Attendance;                          // sheet Attendance (of file attendance_)
  let sourceRangeIndex = ATT_index;                              // B5:B105
  let sourceRangePresence = ATT_AttendanceRange;                 // E5:FQ105
  let sourceSS = SpreadsheetApp.openById(sourceSS_ID);           // file attendance_ is the source spreadsheet
  let sourceSheet = sourceSS.getSheetByName(sourceSheetName);    // sheet "Attendance"
          // get the list of indexes (A5:A105). Filter out only non-blank values
  var sourceDataIndex = sourceSheet.getRange(sourceRangeIndex).getValues()
        .filter(function(value) {
          return value[0] !== ""; // Filter out non-blank values
        });
  var sourceDataIndexLength = sourceDataIndex.length;
        // get the list of presences (E5:FQ105). Slice to the length of sourceDataIndex to get only the values correspondig to the index
  var sourceDataPresence = sourceSheet.getRange(sourceRangePresence).getValues()
        .slice(0, sourceDataIndexLength); 

  let targetSS_ID = STUD_DB_ID;                           // file base_attendance_ // former was file 'studentsDB' ID = 1FPF_vpC7n66fAXjLTpvw7PGMgK1CL1YYHcNtF6X5RIg
  let targetSS = SpreadsheetApp.openById(targetSS_ID);    // file base_attendance_ // former was file 'studentsDB' 
  var [targetSheetName] = STUD_DB_names.split("!");       // uamsPhantom!B5:E // former was studentsDB!B5:E

  let targetRangeIndex = STUD_DB_index;      // C5:C
              // the top most rows of sheet "students" are reserved for the headings, the actual data start after the headings (eg. after the 5. row)
  var targetFirstRow = DATA_FIRST_ROW;       // 5     
              // in the left most columns of sheet "students" are stored the names and other data, the actual data start after these data (eg. after the 23. col). In STUD_DB first col is 24 (col X in A1 notation) because STUD_DB has an additional first column for the timestamp
  // var targetFirstCol = BASE_ATT_attendanceFirstCol + 1;
  var targetFirstCol = BASE_ATT_attendanceFirstCol;         // former was BASE_ATT_attendanceFirstCol + 1 because STUD_DB has an additional first column for the timestamp
              // the number of columns for the presences range in base_attendance_ >>> sheet "students" (between col W and col GI)
  var targetWidth = BASE_ATT_attendanceWidth;   // 169             

  var targetSheet = targetSS.getSheetByName(targetSheetName);                   // sheet uamsPhantom!B5:E // former was sheet "studentsDB"
  var targetDataIndex = targetSheet.getRange(targetRangeIndex).getValues();     // get the list of indexes C5:C
  var targetDataIndexLength = targetDataIndex.length;     

  for (var rowS = 0; rowS < sourceDataIndexLength; rowS++) {     // get one (next) row from array sourceDataIndex (which holds the values of file attendance_ >>> sheet "Attendance")
    var sourceIndexValue = sourceDataIndex[rowS][0];
    
        // compare the source-index (the first cell of the source row) with the target-index of the first (the next) target row
    for (var rowT = 0; rowT < targetDataIndexLength; rowT++) {
      var targetIndexValue = targetDataIndex[rowT][0];
      
      if (sourceIndexValue === targetIndexValue) {                // if they match
        var targetPresenceRow = [];                               // initialize the array to store the row of the presences
        targetPresenceRow.push(sourceDataPresence[rowS]);         // store the row of the presences
              // write the stored row array to the correspondent row of file base_attendance_ >>> sheet "uamsPhantom" // former was file 'studentsDB' >>> sheet "studentsDB"
        targetSheet.getRange(rowT + targetFirstRow, targetFirstCol, 1, targetWidth).setValues(targetPresenceRow); 
        break; // if the first match is found, break the inner loop and continue to the outer loop, this makes it run faster // No need to continue searching for this value
      }
    }
  }
}
/*************************************************************************************/
              // Read file base_attendance_, find who is actually going to school and write them into file attendance_
function updateAttendance() {
              // file 'base_attendance_' is the active spreadsheet which is calling this script and also the spreadsheet where the programDATA are stored. 
var activeSS = SpreadsheetApp.getActive();  
              // in this sheet are stored the data to assign to the variables needed inside this script. This is the central ProgramDATA (belongs to library)
const PROGRAM_DATA_SHEET = SpreadsheetApp.openById('11XtAcRyst1d-JOaSfa2HWFrVfGWivmpYXfirxkAcLHg').getSheetByName('ProgramData');   
const PROGRAM_DATA_SHEET_LOC = activeSS.getSheetByName('ProgramData');                    // this is the local ProgramDATA (belongs to the active file) 
const PROG_DATA = PROGRAM_DATA_SHEET.getDataRange().getValues();                          // get the whole library datasheet
const PROG_DATA_LOC = PROGRAM_DATA_SHEET_LOC.getDataRange().getValues();                  // get the whole local datasheet
const ATT_ID = getVar(PROG_DATA_LOC, 'ATT_ID');                                           // The ID of the local file attendance_ (the local peer)
const ATT_Attendance = getVar(PROG_DATA, 'ATT_Attendance');                               // sheet Attendance (of file attendance_)
const ATT_Names = getVar(PROG_DATA, 'ATT_Names');                                         // sheet 'Names' (of file attendance_)
const ATT_AttendanceRange = getVar(PROG_DATA, 'ATT_AttendanceRange');                     // E5:FQ105
const ATT_NamesRange = getVar(PROG_DATA, 'ATT_NamesRange');                               // A5:D105
// const BASE_ATT_sheetNameStudents = getVar(PROG_DATA, 'BASE_ATT_sheetNameStudents');       // 'students' (sheet name as string 'students'). Sheet 'students' is in file 'base_attendance_'
const BASE_ATT_sheetNameStudents = 'uamsPhantom';       // 'uamsPhantom' (sheet name as string 'uamsPhantom'). Sheet 'uamsPhantom' is in file 'base_attendance_' //former was sheet 'students'
      // const BASE_ATT_attendanceFirstCol = getVar(PROG_DATA, 'BASE_ATT_attendanceFirstCol');     // col 23 (col W in A1 notation)
      // former was col 20 (col T in A1 notation) // former was col 23 (col W in A1 notation)
      // col 24  (col T in A1 notation) changed to 24 because of the addition of the 4 columns "ΣΥΝΟΛΟ ΩΡΙΑΙΩΝ ΑΠΟΥΣΙΩΝ" "ΗΜΕΡΕΣ ΠΑΡΟΥΣΙΩΝ" "ΗΜΕΡΕΣ ΛΕΙΤΟΥΡΓΙΑΣ ΣΧΟΛΕΙΟΥ" "ΠΑΡΟΥΣΙΕΣ %"
const BASE_ATT_attendanceFirstCol = 24;     
const BASE_ATT_names = getVar(PROG_DATA, 'BASE_ATT_names');                               // A5:E105
// const BASE_ATT_attendanceRange = getVar(PROG_DATA, 'BASE_ATT_attendanceRange');           // A5:GJ105
const BASE_ATT_attendanceRange = 'A5:GJ105';           // former was A5:GF105 // former was A5:GJ105
    // const BASE_ATT_attendanceLastCol = getVar(PROG_DATA, 'BASE_ATT_attendanceLastCol');       // col 191 (col GI in A1 notation)
    // former was col 188 (col GF in A1 notation) // former was col 191 (col GI in A1 notation)
    // changed to 192 because of the addition of the 4 columns "ΣΥΝΟΛΟ ΩΡΙΑΙΩΝ ΑΠΟΥΣΙΩΝ" "ΗΜΕΡΕΣ ΠΑΡΟΥΣΙΩΝ" "ΗΜΕΡΕΣ ΛΕΙΤΟΥΡΓΙΑΣ ΣΧΟΛΕΙΟΥ" "ΠΑΡΟΥΣΙΕΣ %"
const BASE_ATT_attendanceLastCol = 192;       
// const BASE_ATT_GOES_TO_SCHOOL = getVar(PROG_DATA, 'BASE_ATT_GOES_TO_SCHOOL');             // col 4 (col D in A1 notation)
const BASE_ATT_GOES_TO_SCHOOL = 8;             // col 8 (8-zero-based=col I in A1 notation) // former was col 4 (col D in A1 notation)
const DATA_FIRST_ROW = getVar(PROG_DATA, 'DATA_FIRST_ROW');                               // row 5
/*************************************************************************************/
        // file "base_attendance_" is the source spreadsheet and also the spreadsheet where the programDATA are stored
  let sourceSS = activeSS;
  let sourceSheetName = BASE_ATT_sheetNameStudents;         // file 'base_attendance_' sheet 'students'
        // this range contains only the names (the first columns in base_attendance_>>>students
  let sourceRangeNames = BASE_ATT_names;                    // A5:E105      
        // this is the whole range of data in base_attendance_>>>students from first column to the last column and from first row to the last row (includes names and presences)
  let sourceDataRange = BASE_ATT_attendanceRange;       // A5:GJ105
  var sourcePresenceFirstCol = BASE_ATT_attendanceFirstCol; // col 23 (col W in A1 notation)
  var sourcePresenceLastCol = BASE_ATT_attendanceLastCol;   // col 191 (col GI in A1 notation)
        // First row of base_attendance_>>>students

  let targetSS_ID = ATT_ID;                                 // The ID of the local file attendance_ (the local peer)
  let targetNames = ATT_Names;                              // sheet Names (of file attendance_)
  let targetAttendance = ATT_Attendance;                    // sheet Attendance (of file attendance_)
        // the first (left) columns in file attendance_>>>Names containing the indexes and the names
  let targetRangeNames = ATT_NamesRange;                    // A5:D105
        // the last (right) columns in file attendance_>>>Attendance containing the presences
  var targetRangePresence = ATT_AttendanceRange;            // E5:FQ105

  let sourceSheet = sourceSS.getSheetByName(sourceSheetName);                       // sheet 'students'
  var sourceData = sourceSheet.getRange(sourceDataRange).getValues();   // A5:GJ105

  let targetSS = SpreadsheetApp.openById(targetSS_ID);                              // file attendance_ 
  let targetSheetNames = targetSS.getSheetByName(targetNames);                      // sheet 'Names' (of file attendance_)
  let targetSheetAttendance = targetSS.getSheetByName(targetAttendance);            // sheet Attendance (of file attendance_)
  let targetDataNames = targetSheetNames.getRange(targetRangeNames);                // A5:D105
  let targetDataPresence = targetSheetAttendance.getRange(targetRangePresence);     // E5:FQ105

  let sourceDataNamesShort = sourceData                                        // sourceDataNames is A5:E105
      .filter(row => row[BASE_ATT_GOES_TO_SCHOOL] === true)                         // filter out just the rows with checked tickbox 
      .map(row => [row[0], row[2], row[3], row[4]]);                            // return just zero-based columns 0,2,3,4 (columns A,C,D,E in A1)
  var sourceDataNamesShortLen = sourceDataNamesShort.length;

  var sourceDataPresenceShort = sourceData                                  // sourceDataPresence is A5:GJ105
      .filter(row => row[BASE_ATT_GOES_TO_SCHOOL] === true)                         // filter out just the rows with checked tickbox
      .map(row => row.slice(sourcePresenceFirstCol - 1, sourcePresenceLastCol));    // return columns from 22 (first col 22 included) to 190 (last col 191 not included)

  targetDataNames.clearContent();                                                   // A5:D105
  targetDataPresence.clearContent();                                                // E5:FQ105
  if (sourceDataNamesShortLen > 0) {
                                    // write the final array of names to the target range (to file attendance_)
    targetDataNames = targetSheetNames.getRange(DATA_FIRST_ROW, 1, sourceDataNamesShortLen, 4); 
    targetDataNames.setValues(sourceDataNamesShort);
                                    // write the final array of presences to the target range (to file attendance_)
    targetDataPresence = targetSheetAttendance.getRange(DATA_FIRST_ROW, 5, sourceDataNamesShortLen, 169); 
    targetDataPresence.setValues(sourceDataPresenceShort);
  }
}
//#endregion WORKING_VERSION_1 01/09/23
/*************************************************************************************/
function getVar(variablesRange, col2){               
  var varRow = variablesRange.filter(function(row){  // filter out the row containing in col2 the name of the variable
      if (row[1] === col2) {
        return row;                                  // return an array (only one row) of arrays (cells)
      }
    });
  return varRow[0][2];   // return only one value as string (the 3. cell of the sole row[0])
}
/*************************************************************************************/
// still needed while undeletableCheckboxes_(e) is not working properly. Can be removed later, after undeletableCheckboxes_(e) is corrected and working
function insertCheckboxes(rangeCheckBox) {
  SpreadsheetApp.getActive().getRange(rangeCheckBox).insertCheckboxes();
}
/*************************************************************************************/
//***********************************************************************
// UNDELETABLE CHECKBOXES START
//***********************************************************************
// uncomment next to use function undeletableCheckboxes_ along with this onEdit(e). In this library another onEdit is checking for intersection.
// /**
// * Simple trigger that runs each time the user hand edits the spreadsheet.
// *
// * @param {Object} e The onEdit() event object.
// */
// function onEdit(e) {
//   if (!e) {
//     throw new Error(
//       'Please do not run the onEdit(e) function in the script editor window. '
//       + 'It runs automatically when you hand edit the spreadsheet.'
//     );
//   }
//   undeletableCheckboxes_(e);
// }

/**
* Makes checkboxes undeletable while keeping them clickable.
*
* Restores a checkbox to its original value when the checkbox is typed over.
* Restores a checkbox to unticked when it is copy-pasted over.
* Restores a checkbox to unticked when it is deleted by pressing Delete.
* Only supports checkboxes with the default values TRUE and FALSE.
* Does not prevent cut and paste of a checkbox from the protected range to another range.
*
* @param {Object} e The onEdit() event object.
*/
function undeletableCheckboxes_(e) {
  // version 1.1, written by --Hyde, 9 January 2023
  //  - replace range with ranges
  //  - see https://support.google.com/docs/thread/196093169
  // version 1.0, written by --Hyde, 11 May 2022
  //  - see https://support.google.com/docs/thread/163207079
  try {
    // uncomment next to use function undeletableCheckboxes_ along with a standalone onEdit(e). In this library another onEdit is checking for intersection.
    // ////////////////////////////////
    // // [START modifiable parameters]
    // const protect = [
    //   {
    //     sheets: /^(uams| | )$/i,
    //     ranges: ['I3', ],
    //   },
    // ];
    // // [END modifiable parameters]
    // ////////////////////////////////

    // if (e.value && e.oldValue !== undefined
    //   && e.value.match(/^(true|false)$/i) && String(e.oldValue).match(/^(true|false)$/i)) {
    if (e.value !== undefined) {
      return;
    }
    // uncomment next to use function undeletableCheckboxes_ along with a standalone onEdit(e). In this library another onEdit is checking for intersection.
    // const sheet = e.range.getSheet();
    // const sheetName = sheet.getName();
    // let intersect;
    // protect.some(prot =>
    //   sheetName.match(prot.sheets) && prot.ranges.some(rangeA1 =>
    //     intersect = getRangeIntersection_(e.range, sheet.getRange(rangeA1))
    //   )
    // );
    // if (!intersect) {
    //   return;
    // }
    e.range.insertCheckboxes().setValue(e.oldValue || "");
    showMessage_('Please do not remove these checkboxes.');
  } catch (error) {
    showAndThrow_(error);
  }
}
 

/**
* Returns the intersection of two ranges as an object that contains a new range, its coordinates and its sheet.
*
* @license https://hyde.mit-license.org/2019
* @param {SpreadsheetApp.Range} range A spreadsheet range object. Optimized for the event object e.range.
* @param {SpreadsheetApp.Range} intersectingRange A spreadsheet range object that possibly overlaps range.
* @return {Object} The intersection of range and intersectingRange, or null if they do not overlap. The return object has these fields:
*                  range       The cells common to range and intersectingRange.
*                  sheet       The sheet of range.
*                  rowStart    The first row of the intersection.
*                  columnStart The first column of the intersection.
*                  rowEnd      The last row of the intersection.
*                  columnEnd   The last column of the intersection.
*                  numRows     The number of rows in the intersection.
*                  numColumns  The number of columns in the intersection.
*/
function getRangeIntersection_(range, intersectingRange) {
  // version 1.7, written by --Hyde, 27 October 2021
  const result = { sheet: range.getSheet() };
  if (result.sheet.getSheetId() !== intersectingRange.getSheet().getSheetId()) {
    return null;
  }
  result.columnStart = Math.max(range.columnStart || range.getColumn(), intersectingRange.getColumn());
  result.columnEnd = Math.min(range.columnEnd || range.getLastColumn(), intersectingRange.getLastColumn());
  if (result.columnStart > result.columnEnd) {
    return null;
  }
  result.rowStart = Math.max(range.rowStart || range.getRow(), intersectingRange.getRow());
  result.rowEnd = Math.min(range.rowEnd || range.getLastRow(), intersectingRange.getLastRow());
  if (result.rowStart > result.rowEnd) {
    return null;
  }
  result.numRows = result.rowEnd - result.rowStart + 1;
  result.numColumns = result.columnEnd - result.columnStart + 1;
  result.range = result.sheet.getRange(result.rowStart, result.columnStart, result.numRows, result.numColumns);
  return result;
}
 

/**
* Shows error.message in a pop-up and throws the error.
*
* @param {Error} error The error to show and throw.
*/
function showAndThrow_(error) {
  // version 1.0, written by --Hyde, 16 April 2020
  var stackCodeLines = String(error.stack).match(/\d+:/);
  if (stackCodeLines) {
    var codeLine = stackCodeLines.join(', ').slice(0, -1);
  } else {
    codeLine = error.stack;
  }
  showMessage_(error.message + ' Code line: ' + codeLine, 30);
  throw error;
}
 

/**
* Shows a message in a pop-up.
*
* @param {String} message The message to show.
* @param {Number} timeoutSeconds Optional. The number of seconds before the message goes away. Defaults to 5.
*/
function showMessage_(message, timeoutSeconds) {
  // version 1.0, written by --Hyde, 16 April 2020
  SpreadsheetApp.getActive().toast(message, 'Undeletable checkboxes', timeoutSeconds || 5);
}
//***********************************************************************
// UNDELETABLE CHECKBOXES END
//***********************************************************************
 /*************************************************************************************/
// function actualizeAttendance(e) {
  // This function is to copy and to use within a particular bound script when needed mainly for test and debugging purposes. 
  //   SpreadsheetApp.flush();  
  //   Utilities.sleep(3000); // 1000 milliseconds = 1 second
  //   updateAttendance();
  // }
/*************************************************************************************/
// function getVariables(progData, col1){   // filter out the rows containing in col1 the name of the calling function
  // This function is not used within this library. Uncomment to use it. 
  //   return progData.filter(function(row){
  //     if (row[0] === col1) {
  //       return row;                        // return an array of arrays (rows) 
  //     }
  //   });
  // }
/*************************************************************************************/
//*******************************************************************************************************************************************************
  // global declarations no more used in this version as they conflict with execution of onOpen() for menu creation. Instead of declaring variables globally, just variables needed by a function are declared locally at start of each function 
  // //*******************************************************************************************************************************************************
  // // GLOBAL  **********************************************************************************************************************************************
  // //*******************************************************************************************************************************************************
  //               // file 'base_attendance_' is the active spreadsheet which is calling this script and also the spreadsheet where the programDATA are stored. 
  // var activeSS = SpreadsheetApp.getActive();  
  //               // in this sheet are stored the data to assign to the variables needed inside this script. This is the central ProgramDATA (belongs to library)
  // const PROGRAM_DATA_SHEET = SpreadsheetApp.openById('11XtAcRyst1d-JOaSfa2HWFrVfGWivmpYXfirxkAcLHg').getSheetByName('ProgramData');   
  // const PROGRAM_DATA_SHEET_LOC = activeSS.getSheetByName('ProgramData');                    // this is the local ProgramDATA (belongs to the active file) 
  // const PROG_DATA = PROGRAM_DATA_SHEET.getDataRange().getValues();                          // get the whole library datasheet
  // const PROG_DATA_LOC = PROGRAM_DATA_SHEET_LOC.getDataRange().getValues();                  // get the whole local datasheet
  // const ATT_ID = getVar(PROG_DATA_LOC, 'ATT_ID');                                           // The ID of the local file attendance_ (the local peer)
  // const ATT_Attendance = getVar(PROG_DATA, 'ATT_Attendance');                               // sheet Attendance (of file attendance_)
  // const ATT_Names = getVar(PROG_DATA, 'ATT_Names');                                         // sheet 'Names' (of file attendance_)
  // const ATT_AttendanceRange = getVar(PROG_DATA, 'ATT_AttendanceRange');                     // E5:FQ105
  // const ATT_index = getVar(PROG_DATA, 'ATT_index');                                         // B5:B105
  // const ATT_NamesRange = getVar(PROG_DATA, 'ATT_NamesRange');                               // A5:D105
  // const BASE_ATT_sheetNameStudents = getVar(PROG_DATA, 'BASE_ATT_sheetNameStudents');       // 'students' (sheet name as string 'students'). Sheet 'students' is in file 'base_attendance_'
  // // const BASE_ATT_index = getVar(PROG_DATA, 'BASE_ATT_index');                            // replaced with STUD_DB_index  02/09/2023
  // const BASE_ATT_attendanceFirstCol = getVar(PROG_DATA, 'BASE_ATT_attendanceFirstCol');     // col 23 (col W in A1 notation)
  // const BASE_ATT_attendanceWidth = getVar(PROG_DATA, 'BASE_ATT_attendanceWidth');           // width 169 columns
  // const BASE_ATT_names = getVar(PROG_DATA, 'BASE_ATT_names');                               // A5:E105
  // const BASE_ATT_attendanceRange = getVar(PROG_DATA, 'BASE_ATT_attendanceRange');           // A5:GJ105
  // const BASE_ATT_attendanceLastCol = getVar(PROG_DATA, 'BASE_ATT_attendanceLastCol');       // col 191 (col GI in A1 notation)
  // const BASE_ATT_GOES_TO_SCHOOL = getVar(PROG_DATA, 'BASE_ATT_GOES_TO_SCHOOL');             // col 4 (col D in A1 notation)
  // const DATA_FIRST_ROW = getVar(PROG_DATA, 'DATA_FIRST_ROW');                               // row 5
  // // This is because of permission to access STUD_DB_ID. Writing is redirected to file base_attendance_ (the file which calls this library)
  // // const STUD_DB_ID = getVar(PROG_DATA_LOC, 'STUD_DB_ID');                                   // file 'studentsDB' ID = 1FPF_vpC7n66fAXjLTpvw7PGMgK1CL1YYHcNtF6X5RIg
  // const STUD_DB_ID = activeSS.getId();                                   // redirect to file base_attendance_ (this file) because of permission issues
  // const STUD_DB_names = getVar(PROG_DATA_LOC, 'STUD_DB_names');                             // studentsDB!B5:E
  // const STUD_DB_index = getVar(PROG_DATA_LOC, 'STUD_DB_index');                             // C5:C
  // const THIS_SHELTER_ID = getVar(PROG_DATA_LOC, 'THIS_SHELTER_ID');
/*************************************************************************************/
